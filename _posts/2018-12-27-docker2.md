---
layout: post
title:  "Docker: 网络模型"
subtitle: "Docker四种网络模型实践"
date:   2018-12-27 10:45:13 -0400
background: '/img/posts/docker-cover.png'
---

## 在服务器分别运行四种网络模型的Docker

1. 以默认模式（bridge）运行一个ubuntu容器，并在容器中查看网络配置 
<img class="img-fluid" src="/img/posts/post_docker_2/1-1.png">  
Docker会从RFC1918所定义的私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用。如一般Docker会使用172.17.0.0/16这个网段  
- 查看当前主机网桥
<img class="img-fluid" src="/img/posts/post_docker_2/1-2.png">  
- `ethtool –S ethX ` //查询ethX网口收发包统计  
<img class="img-fluid" src="/img/posts/post_docker_2/1-3.png"> 
2. 以host模式运行一个ubuntu容器
<img class="img-fluid" src="/img/posts/post_docker_2/2-1.png"> 
相比在宿主机上的网络环境，发现是一样的
<img class="img-fluid" src="/img/posts/post_docker_2/2-2.png"> 
3. 以none模式启动容器查看网络配置，发现这个容器没有网卡、IP、路由等信息，需要我们自己为容器添加网卡，配置IP
<img class="img-fluid" src="/img/posts/post_docker_2/3.png">
4. 以container模式，指定一个正在运行的容器（刚才以none模式启动的容器），发现两个容器的网络配置完全相同
<img class="img-fluid" src="/img/posts/post_docker_2/4.png">



## 四种网络模式介绍

`-net=X` 进行设置

- bridge（默认）：为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上,Docker会将一端挂载到docker0网桥上，另一端放入容器的Network Namespace内，从而实现容器与主机通信的目的。

  - 创建虚拟网桥:

    在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备

  - 容器连接网桥：

    Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看，但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。

  - 分配ip：

    从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关
  <img class="img-fluid" src="/img/posts/post_docker_2/01.png">
- host：容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口 
  <img class="img-fluid" src="/img/posts/post_docker_2/02.png">
- none：Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。 

- container：指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。
  <img class="img-fluid" src="/img/posts/post_docker_2/03.png">
  <img class="img-fluid" src="/img/posts/post_docker_2/04.png">


- 通过端口公开（port exposure）连接

- 将宿主机端口绑定（bind）至容器端口
- 通过链接（link）选项去连接两个容器



## 一些补充知识
- 默认docker0 网桥配置，可以修改 /etc/docker/daemon.json来修改网桥配置，但不可以和宿主机在同网段  
  <img class="img-fluid" src="/img/posts/post_docker_2/3-1.png">
- RFC1918定义的私有IP网段
IPv4地址分为A、B、C、D、E五类，出去特殊作用的D、E两类，剩下的A、B、C三类地址是我们常见的IP地址段。A类地址的容量最大，可以容纳16777214个主机，B类地址可以容纳65534个主机，C类地址可以容纳254个主机。
在这三类地址中，绝大多数的IP地址都是公有地址，需要向国际互联网信息中心申请注册。但是在IPv4地址协议中预留了3个IP地址段，作为私有地址，供组织机构内部使用。
这三个地址段分别位于A、B、C三类地址内：
  - A类地址：10.0.0.0--10.255.255.255
  - B类地址：172.16.0.0--172.31.255.255 
  - C类地址：192.168.0.0--192.168.255.255
所以局域网在选取使用私有地址时，一般会按照实际需要容纳的主机数来选择私有地址段。常见的局域网由于容量小，一般选择C类的192.168.0.0作为地址段使用，一些大型企业就需要使用B类甚至A类地址段作为内部网络的地址段。
- NAT:Network Address Translation，网络地址转换，主要用于实现私有IP到公有IP，一般有路由器来完成  
在`/etc/sysctl.conf`中可以开启数据转发功能  
  <img class="img-fluid" src="/img/posts/post_docker_2/3-2.png">
- IP（IPv4）地址分为公网IP地址和私网IP地址。公有地址在公网中是不能重复的，因此公网IP地址是一种有限资源；而私网IP地址在不同的子网内是可以复用，可以自行分配的。
DHCP（Dynamic Host Configuration Protocol）一般是用于分配私网IP地址，当然土豪也可以用来分配公网IP。
公网IP的分配是由IANA(The Internet Assigned Numbers Authority）分配的，可是美国人坏坏，给自己分了3/4的地址，目前大概有16亿个，中国地区目前只有3亿多个，明显是不够用的，那为什么却可以让超过3亿人同时上网呢?   
解决方案是`NAT(Network Address Translation)`，准确地讲是`PAT(Port Address Translation)`。IP地址是用来区别主机的，而TCP/UDP的port则是区分不同的进程的，有几万个可用。一般用户用不了这么多端口，一个公网IP地址就拥有了几万个端口资源。这样一来出口网络设备就可以将（私网IP，端口）与（公网IP，端口）建立映射关系，TCP/UDP数据包进出时做一下SNAT和DNAT就行了，出去的时候源IP转换为了公网IP，回来的时候根据目的IP转换成成对应的私网IP，一个公网地址就可以让多台计算机同时访问网络了。
- 查看主机NAT规则  
`PREROUTING`：位于NAT机制的最前面，主要是修改数据包的Destination IP，主要执行DNAT任务。  
`POSTROUTING`：位于NAT机制的最末端，主要是修改数据包的Source IP，只要执行SNAT任务。  
`OUTPUT`：当本机进程需要将数据包发出本机时，先要经过OUTPUT链匹配，如果匹配成功允许发出，才会将数据包交给`POSTROUTING`链进行SNAT。  
  <img class="img-fluid" src="/img/posts/post_docker_2/3-3.png">
将所有源地址在172.17.0.0/16的网段，目标地址的流量伪装成从系统网卡发出，  
`MASQUERADE` 可以动态从网卡获取地址  
运行一个随机映射端口的nginx容器，并查看端口映射  
  <img class="img-fluid" src="/img/posts/post_docker_2/3-4.png">  
再查看NAT表，发现多了一个DNAT的转换，容器172.17.0.2的80端口被映射到了宿主机的32770端口  
  <img class="img-fluid" src="/img/posts/post_docker_2/3-5.png">

- why单进程docker
	- docker想解决的问题
	  - 轻量级的资源隔离
	  - 简洁一致的部署环境
	- 一个容器中运行多进程，如果某进程异常退出，docker ps无法了解内部运行状态，容器将无法进行下一步判断
	- 不同应用：个人开发环境部署/ 真正生产环境
- 最佳实践
	- 能否进行网络信息统计：bridge方便监视各个容器，获取容器的网络统计信息，而host模式下的容器无法获得这些信息
	- 网络吞吐量不同：host模式为原始网络吞吐量的100%，而bridge模式为吞吐量的80%
		因为外界访问访问容器时，采用了端口绑定的方法，也就是iptables的NAT，将宿主端口流量转发到容器内端口，性能和效率有所损耗
  - host/ bridge对应单进程容器/ 多个多进程容器
